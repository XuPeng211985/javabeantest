package keyword.inner;
import javax.swing.*;
import java.util.Map;

/**
 * 内部类定义：定义在另一个类中的类
 * 为什么要用到内部类：
 *        1：内部类不仅可以访问自身的数据域，还可以访问创建它的外围类对象的数据域
 *        2：内部类可以对同一包下的其他类所隐藏起来
 *        3：使用内部类可以方便的实现回调函数
 *        4：内部类可以继承一个类，外部类可以继承一个类，这样就实现了多继承
 * 特点 ：内部类的对象总有一个隐式引用，指向创建它的外部类对象
 *
 * 分类 ：静态内部类-->优点是不用拿到外部类对象引用就可以实例化内部类
 *                     缺点是只能访问外部类的静态成员数据
 *                     注：静态内部类的对象除了没有对生成它的外围类对象的引用特权外，与
 *                         其他内部类完全一样
 *        局部内部类-->优点一是对外部世界完全的隐藏起来，除了包含该内部类的方法之外 不会有第三方直到它的存在
 *                     优点二是可以访问被final修饰的局部变量，这样的好处是当局部内部类所在方法
 *                            的形参变量在释放之前用该方法的局部变量做一个备份，以便内部类后续访问形参变量的值
 *                     缺点是不能被public或private等访问修饰符修饰，它的作用仅仅被限制在了声明这个局部内部类
 *                            的块中。
 *        匿名内部类-->通常情况下，我们定义内部类只是为了使用它的一个实例对象，而不太关注它叫什么
 *                      此时我们可以把该类定义为匿名内部类，就像例子中的实现ActionListener接口
 *                      的内部类，我们只需要一个实现接口的实例，所以此时我们可以直接
 *                      在该接口后面的大括号里实现它的抽象方法，这样可以节省一些不必要的代码量
 *  闭包和内部类：当内部类使用外部的局部变量时，实际上形成了闭包，被使用的这个
 *          局部变量不会随着方法的执行完毕而消失，因为内部类的实例可能还会用到
 *          这个变量，所以如果在内部类中使用到了外部方法的变量，需要用final修饰
 *          JDK8中将会主动识别，并把局部变量设为final
 */
public class InnerClassTest {
    public static void main(String[] args) {
        TalkingClock clock = new TalkingClock(1000,false);
        clock.start();
        JOptionPane.showConfirmDialog(null,"Quit program");
        System.exit(0);
    }
}
