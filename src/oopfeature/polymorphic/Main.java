package oopfeature.polymorphic;
/**
 * 谈谈多态与动态绑定机制：
 *    多态性是指不同子类遵循一个框架结构，但是可以有各自不同的实现
 *          这样子类就可以对同一个消息做出不同的响应，通俗的说就是
 *          人和绵羊同样是动物，但是在吃这个动作上，人要用碗吃，而绵羊
 *          是用嘴吃；只要是动物他就有吃这个动作，所以当我们想让一个绵羊
 *          执行吃这个动作，我们只需要声明一个动物类型的对象引用指向new的一个绵羊对象
 *          我们只需要关注动物吃这个动作，而把具体吃食物的内容和过程交给子类绵羊
 *          这样就很好地实现了父类与子类之间的低耦合，代码复用 并且尽量低耦合是面向对象
 *          语言设计一直追求的目标。
 *  动态绑定机制：它是多态的重要特性之一，动态绑定机制系统的维持了，为什么调动
 *                 动物类型的吃方法可以准确的找到绵羊类型对象的吃方法
 *  下面例子中（父类：Person 子类：Student）静态以f2方法为准  动态以f1为准：
 *  静态绑定机制：
 *         1 ：调用f1方法，JVM把它加载为一条字节码指令，根据该指令jvm会在常量池
 *             中的某个常量表中找到方法f1信息的符号引用（包括方法名,类名和返回类型），根据该引用
 *             确定调用该方法的类的全限定名 （父类的全路径）
 *         2 ：根据1中确定的类路径找到类所在位置，链接初始化Person类
 *         3 ：霸气的常量池解析，在Person类的方法区中找到对应的f1方法
 *             的直接地址，然后将该方法的直接地址存放在f1信息符号引用所在的常量表中
 *             以便下次调用的时候使用
 *         4：直接调用f2方法里的指令
 * 动态绑定机制 ：（简单介绍一下方法表：记录当前类以及父类的可见方法在内存中的直接地址）
 *         1 ：调用f2方法，JVM把它加载为一条字节码指令，根据该指令jvm会在常量池
 *             中的某个常量表中找到方法f2信息的符号引用（包括方法名,类名和返回类型），根据该引用
 *             确定调用该方法的类的全限定名 （父类的全路径）
 *         2 ：在Person类所在的方法表中查找f1的直接地址索引，如果找到合适的方法则将该地址索引存储到f1
 *             信息引用所在的常量表中（常量池解析）
 *            （合适指的是如果方法签名不完全一样，会找参数自动转型后所匹配的方法）
 *         3 ：接着会把之前在堆中new的Student对象的引用压入操作数栈，在调用f1方法的过程中
 *             JVM会根据Student对象的引用找到该对象的直接地址，并且进一步找到该对象所属类的
 *             方法表
 *         4：最后根据f1所在常量表中的直接地址引用，在子类（Student）的方法表中找到f1的直接地址
 *            并且执行方法内部的指令。
 */
public class Main {
    public static void main(String[] args) {
        Person p = new Student();
        Person.f2(66);
        p.f1();
    }
}
