package oopfeature.abstresctorinterface;
/**
 * 是什么：抽象类是用来捕捉子类的通用特性 虽然有构造器但是不能被实例化
 *         更进一步说抽象类为它的子类提供一个类模板，子类必须遵循这个模板
 *
 *         接口是一些抽象方法的组合，如果一个类想要实现某个接口，就必须把
 *         该接口中的所有抽象方法都具体实现（接口本身什么事都不做）
 *区别：1. 抽象类是一个不允许实例化的类，而接口只是一系列抽象方法的集合
 *      2. 一个类用extends关键字继承一个抽象类，如果它不想自己是一个抽象类他就必须实现父类的所有
 *         抽象方法；一个类用implements关键字实现一个接口，它必须实现该接口中
 *         的所有抽象方法
 *      3 .抽象类中既包含抽象方法也包含普通方法和成员变量，而接口中的所有方法都是抽象的
 *      4. 抽象类中的抽象方法可以被public protected和default修饰 而接口中的抽象方法的修饰符必须是public
 * 应用场景：如果你需要设计一个较顶层的类，并且该类中的某些方法暂时不知道该如何实现
 *       那此时你应该把这个较顶层的类设计为抽象类;在设计这个抽象类的子类时发现
 *       所有的子类都有一些特有的行为需要实现，并且父类中没有这些行为的入口，那么
 *       此时可以把这些行为提取出来抽象为一些接口，然后由子类来实现选择一个接口或多个接口
 * 举例：上司要求你做一个披萨专卖店系统，由于规模比较大，以总店为中心还有很多
 *       小分店，并且每个小分店生产出来的披萨都有各自的特色；
 *       此时作为开发人员的我们就需要在脑海中构建一个模型结构：总店作为一个披萨店
 *       它需要披萨属性，还需要实现正常的披萨打包的一系列动作，接着将披萨发送给客户
 *       接着思考作为一个披萨总店，只需要负责打包披萨销售而不需要知道披萨的具体制作
 *       过程，但是又不得不通过某个方式获得制造好的披萨，此时我们就可以把这个披萨总店
 *       设计为一个抽象类，该类除了披萨属性和具体的加工流程以外还包含一个接受披萨
 *       的抽象通道。然后所有分店继承这个抽象类，这些分店专心负责制造各色口味的
 *       披萨。
 *       在分店加工披萨的过程中又会出现一次选择，无论哪种披萨都会使用特定的
 *       几种佐料（比如面粉 奶酪 芝士等），但是每个分店的这几种佐料都有自己不同的风格
 *       此时我们可以把这几种佐料的加工都包装在一个接口中，每个分店类只需要
 *       用自己的特色佐料加工方案实现这个接口即可。
 * 总结：最本质的区别还是 抽象类是个类抽象的主体是类 而接口是个抽象行为集合，
 *       接口是对一系列行为的抽象。
 */
public abstract class AbstractTest {
     abstract void fun();
}
